// kafka-connector options: START
[[camel-rabbitmq-kafka-connector-source]]
= camel-rabbitmq-kafka-connector source configuration

When using camel-rabbitmq-kafka-connector as source make sure to use the following Maven dependency to have support for the connector:

[source,xml]
----
<dependency>
  <groupId>org.apache.camel.kafkaconnector</groupId>
  <artifactId>camel-rabbitmq-kafka-connector</artifactId>
  <version>x.x.x</version>
  <!-- use the same version as your Camel Kafka connector version -->
</dependency>
----


The camel-rabbitmq source connector supports 93 options, which are listed below.



[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Priority
| *camel.source.path.exchangeName* | The exchange name determines which exchange produced messages will sent to. In the case of consumers, the exchange name determines which exchange the queue will bind to. | null | ConfigDef.Importance.HIGH
| * camel.source.endpoint.addresses* | If this option is set, camel-rabbitmq will try to create connection based on the setting of option addresses. The addresses value is a string which looks like server1:12345, server2:12345 | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.auto Delete* | If it is true, the exchange will be deleted when it is no longer in use | true | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.automatic RecoveryEnabled* | Enables connection automatic recovery (uses connection implementation that performs automatic recovery when existing connection has failures) | "true" | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.connection Factory* | To use a custom RabbitMQ connection factory. When this option is set, all connection options (connectionTimeout, requestedChannelMax...) set on URI are not used | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.dead LetterExchange* | The name of the dead letter exchange | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.dead LetterExchangeType* | The type of the dead letter exchange One of: [direct] [fanout] [headers] [topic] | "direct" | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.dead LetterQueue* | The name of the dead letter queue | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.dead LetterRoutingKey* | The routing key for the dead letter exchange | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.declare* | If the option is true, camel declare the exchange and queue name and bind them together. If the option is false, camel won't declare the exchange and queue name on the server. | true | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.durable* | If we are declaring a durable exchange (the exchange will survive a server restart) | true | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.exchange Type* | The exchange type such as direct or topic. One of: [direct] [fanout] [headers] [topic] | "direct" | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.exclusive* | Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes. | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.hostname* | The hostname of the running rabbitmq instance or cluster. | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.passive* | Passive queues depend on the queue already to be available at RabbitMQ. | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.port Number* | Port number for the host with the running rabbitmq instance or cluster. Default value is 5672. | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.queue* | The queue to receive messages from | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.routing Key* | The routing key to use when binding a consumer queue to the exchange. For producer routing keys, you set the header rabbitmq.ROUTING_KEY. | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.skip ExchangeDeclare* | This can be used if we need to declare the queue but not the exchange | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.skip QueueBind* | If true the queue will not be bound to the exchange after declaring it | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.skip QueueDeclare* | If true the producer will not declare and bind a queue. This can be used for directing messages via an existing routing key. | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.vhost* | The vhost for the channel | "/" | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.autoAck* | If messages should be auto acknowledged | true | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.bridge ErrorHandler* | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.concurrent Consumers* | Number of concurrent consumers when consuming from broker. (eg similar as to the same option for the JMS component). | 1 | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.exclusive Consumer* | Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful when you want a long-lived shared queue to be temporarily accessible by just one consumer. | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.prefetch Count* | The maximum number of messages that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.prefetch Enabled* | Enables the quality of service on the RabbitMQConsumer side. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.prefetch Global* | If the settings should be applied to the entire channel rather than each consumer You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.prefetch Size* | The maximum amount of content (measured in octets) that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time | null | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.exception Handler* | To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored. | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.exchange Pattern* | Sets the exchange pattern when the consumer creates an exchange. One of: [InOnly] [InOut] [InOptionalOut] | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.thread PoolSize* | The consumer uses a Thread Pool Executor with a fixed number of threads. This setting allows you to set that number of threads. | 10 | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.args* | Specify arguments for configuring the different RabbitMQ concepts, a different prefix is required for each: Exchange: arg.exchange. Queue: arg.queue. Binding: arg.binding. For example to declare a queue with message ttl argument: \http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000 | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.basic PropertyBinding* | Whether the endpoint should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.client Properties* | Connection client properties (client info used in negotiating with the server) | null | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.connection Timeout* | Connection timeout | 60000 | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.network RecoveryInterval* | Network recovery interval in milliseconds (interval used when recovering from network failure) | "5000" | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.requested ChannelMax* | Connection requested channel max (max number of channels offered) | 2047 | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.requested FrameMax* | Connection requested frame max (max size of frame offered) | 0 | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.requested Heartbeat* | Connection requested heartbeat (heart-beat in seconds offered) | 60 | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.request Timeout* | Set timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds) | 20000L | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.request TimeoutCheckerInterval* | Set requestTimeoutCheckerInterval for inOut exchange | 1000L | ConfigDef.Importance.MEDIUM
| * camel.source.endpoint.synchronous* | Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported). | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.topology RecoveryEnabled* | Enables connection topology recovery (should topology recovery be performed) | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.transfer Exception* | When true and an inOut Exchange failed on the consumer side send the caused Exception back in the response | false | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.password* | Password for authenticated access | "guest" | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.ssl Protocol* | Enables SSL on connection, accepted value are true, TLS and 'SSLv3 | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.trust Manager* | Configure SSL trust manager, SSL should be enabled for this option to be effective | null | ConfigDef.Importance.MEDIUM
| *camel.source.endpoint.username* | Username in case of authenticated access | "guest" | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.addresses* | If this option is set, camel-rabbitmq will try to create connection based on the setting of option addresses. The addresses value is a string which looks like server1:12345, server2:12345 | null | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.auto Delete* | If it is true, the exchange will be deleted when it is no longer in use | true | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.connection Factory* | To use a custom RabbitMQ connection factory. When this option is set, all connection options (connectionTimeout, requestedChannelMax...) set on URI are not used | null | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.dead LetterExchange* | The name of the dead letter exchange | null | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.dead LetterExchangeType* | The type of the dead letter exchange One of: [direct] [fanout] [headers] [topic] | "direct" | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.dead LetterQueue* | The name of the dead letter queue | null | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.dead LetterRoutingKey* | The routing key for the dead letter exchange | null | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.declare* | If the option is true, camel declare the exchange and queue name and bind them together. If the option is false, camel won't declare the exchange and queue name on the server. | true | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.durable* | If we are declaring a durable exchange (the exchange will survive a server restart) | true | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.exclusive* | Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes. | false | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.hostname* | The hostname of the running RabbitMQ instance or cluster. | null | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.passive* | Passive queues depend on the queue already to be available at RabbitMQ. | false | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.port Number* | Port number for the host with the running rabbitmq instance or cluster. | 5672 | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.skip ExchangeDeclare* | This can be used if we need to declare the queue but not the exchange | false | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.skip QueueBind* | If true the queue will not be bound to the exchange after declaring it | false | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.skip QueueDeclare* | If true the producer will not declare and bind a queue. This can be used for directing messages via an existing routing key. | false | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.vhost* | The vhost for the channel | "/" | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.auto Ack* | If messages should be auto acknowledged | true | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.bridge ErrorHandler* | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.exclusive Consumer* | Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful when you want a long-lived shared queue to be temporarily accessible by just one consumer. | false | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.prefetch Count* | The maximum number of messages that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time | null | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.prefetch Enabled* | Enables the quality of service on the RabbitMQConsumer side. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time | false | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.prefetch Global* | If the settings should be applied to the entire channel rather than each consumer You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time | false | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.prefetch Size* | The maximum amount of content (measured in octets) that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time | null | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.thread PoolSize* | The consumer uses a Thread Pool Executor with a fixed number of threads. This setting allows you to set that number of threads. | 10 | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.args* | Specify arguments for configuring the different RabbitMQ concepts, a different prefix is required for each: Exchange: arg.exchange. Queue: arg.queue. Binding: arg.binding. For example to declare a queue with message ttl argument: \http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000 | null | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.auto DetectConnectionFactory* | Whether to auto-detect looking up RabbitMQ connection factory from the registry. When enabled and a single instance of the connection factory is found then it will be used. An explicit connection factory can be configured on the component or endpoint level which takes precedence. | true | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.automatic RecoveryEnabled* | Enables connection automatic recovery (uses connection implementation that performs automatic recovery when connection shutdown is not initiated by the application) | null | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.basic PropertyBinding* | Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities | false | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.client Properties* | Connection client properties (client info used in negotiating with the server) | null | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.connection Timeout* | Connection timeout | 60000 | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.network RecoveryInterval* | Network recovery interval in milliseconds (interval used when recovering from network failure) | "5000" | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.requested ChannelMax* | Connection requested channel max (max number of channels offered) | 2047 | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.requested FrameMax* | Connection requested frame max (max size of frame offered) | 0 | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.requested Heartbeat* | Connection requested heartbeat (heart-beat in seconds offered) | 60 | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.request Timeout* | Set timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds) | 20000L | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.request TimeoutCheckerInterval* | Set requestTimeoutCheckerInterval for inOut exchange | 1000L | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.topology RecoveryEnabled* | Enables connection topology recovery (should topology recovery be performed) | null | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.transfer Exception* | When true and an inOut Exchange failed on the consumer side send the caused Exception back in the response | false | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.password* | Password for authenticated access | "guest" | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.ssl Protocol* | Enables SSL on connection, accepted value are true, TLS and 'SSLv3 | null | ConfigDef.Importance.MEDIUM
| *camel.component.rabbitmq.trust Manager* | Configure SSL trust manager, SSL should be enabled for this option to be effective | null | ConfigDef.Importance.MEDIUM
| * camel.component.rabbitmq.username* | Username in case of authenticated access | "guest" | ConfigDef.Importance.MEDIUM
|===
// kafka-connector options: END
